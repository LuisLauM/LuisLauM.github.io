[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "EN: Here I will be depositing several articles of very diverse topics.\nES: Aquí iré depositando contenido sobre temas muy diversos.\nImage credits: Siora Photography at Unplash\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s working with marbec-gpu\n\n\nRunning R scripts in marbec-gpu. | Ejecutar scripts de R usando marbec-gpu.\n\n\n\n\n\nOct 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nManaging files within marbec-data\n\n\nHow to manage files and carpetas to and from marbec-data? | ¿Cómo gestionar archivos y carpetas desde y hacia marbec-data?\n\n\n\n\n\nOct 24, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMain commands in marbec-gpu Terminal\n\n\nA quick list of the main commands to use within the marbec-gpu Terminal. | Un listado rápido de los principales comandos para usar dentro de la Terminal de marbec-gpu.\n\n\n\n\n\nOct 23, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to marbec-data and marbec-gpu\n\n\nWhat they are and how to access? | ¿Qué son y cómo acceder a ellos?\n\n\n\n\n\nOct 21, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEl Niño\n\n\nCurrent conditions for the Peruvian coast. | Condiciones actuales para la costa peruana.\n\n\n\n\n\nApr 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeveloping Beneath the surface\n\n\nCómo fui desarrollando esta página\n\n\n\n\n\nApr 19, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "EN\nMy full name is Luis Wencheng Lau-Medrano, I am Peruvian by birth and a passionate (geek) about technology, marine biology, data analysis, Legos and travel. Since I was a child, I have been fascinated by the digital world and biology, so when I became an adult, I decided to combine both passions to solve problems and improve people’s lives (and my own, which I am working on).\nIn my professional career, I complete my bachelor as biologist with a specialization in Hydrobiology at the UNMSM (Lima-Peru), then I continued with a Master’s degree in Marine Sciences at the UPCH (Lima-Peru). Currently, I am finishing a doctorate in ecology at the University of Montpellier-UM (France) with an IRD scholarship.\nI have worked as a researcher at the Instituto del Mar del Perú-IMARPE, in the General Directorate of Pelagic Resources Research and in the General Directorate of Demersal and Littoral Resources Research. My main tasks were the statistical analysis of fishery information and research cruises for decision-making and management of the anchovy (Engraulis ringens), jack mackerel (Trachurus murphyi), mackerel (Scomber japonicus), hake (Merluccius gayi peruanus) and giant squid (Dosidicus gigas). Additionally, I have done two internships: one at the University of Washington-UW for the standardization of the CPUE of two shark species using the VAST tool, and another at the UM supporting the calibration of the OSMOSE model for the Peruvian Upwelling Ecosystem. I have experience as a speaker at international congresses held in Lima-Peru, La Paz-Mexico, Victoria-Canada and Palma de Mallorca-Spain.\nI have also experience teaching programming and data management courses and I am the creator and developer of the packages in CRAN imagine and grec.\nHobbies? Of course! Video games, building Legos, biking, traveling, taking pictures of natural and urban landscapes and programming (yes, also as a hobbie).\n\n\nES\nMi nombre completo es Luis Wencheng Lau-Medrano, soy peruano de nacimiento y un apasionado de la tecnología (un geek quizás), la biología marina, el análisis de datos, los Legos y los viajes. Desde siempre me ha fascinado el mundo digital y la biología, por lo que llegado el momento de ser adulto decidí combinar ambas pasiones para resolver problemas y mejorar la vida de las personas (y la mía propia, en ello trabajo).\nMi formación profesional inicial es de biólogo con mención en Hidrobiología en la UNMSM (Lima-Perú), luego continué con una Maestría en Ciencias del Mar en la UPCH (Lima-Perú). Actualmente, vengo finalizando un doctorado en ecología en la Universidad de Montpellier-UM (Francia) con el apoyo de una beca IRD.\nHe trabajado como investigador en el Instituto del Mar del Perú-IMARPE, en la Dirección General de Investigaciones de Recursos Pelágicos y en la Dirección General de Investigaciones de Recursos Demersales y Litorales. Mis labores principales fueron el análisis estadístico de información de pesquería y cruceros de investigación para la toma de decisiones y manejo de los recursos anchoveta (Engraulis ringens), jurel (Trachurus murphyi), caballa (Scomber japonicus), merluza (Merluccius gayi peruanus) y pota (Dosidicus gigas). Adicionalmente, he realizado dos pasantías: una en la Universidad de Washington-UW para la estandarización de la CPUE de dos especies de tiburones usando la herramienta VAST, y otra en la UM apoyando con la calibración del modelo OSMOSE para el Ecosistema de Afloramiento Peruano. Tengo experiencia como expositor en congresos internacionales realizados en Lima-Perú, La Paz-México, Victoria-Canadá y Palma de Mayorca-España.\nTambién tengo experiencia docente cursos de programación y manejo de datos y soy creador y desarrollador de los paquetes en CRAN imagine y grec.\n¿Hobbies? ¡Por supuesto! Juegos de video, armar Legos, pasear en bicicleta, viajar, tomar fotos de paisajes naturales y urbanos y programar (sí, también como hobbie)."
  },
  {
    "objectID": "blog/marbec-gpu-main-cmds/marbec-gpu-main-cmds.html",
    "href": "blog/marbec-gpu-main-cmds/marbec-gpu-main-cmds.html",
    "title": "Main commands in marbec-gpu Terminal",
    "section": "",
    "text": "Image credits: Kajetan Sumila at Unplash\n\n[EN] Main commands in marbec-gpu Terminal\nThe first thing to keep in mind is that marbec-gpu has Ubuntu installed, so the commands listed below will be the same as the ones used in that OS. This article will show a description of the main usage modes for each command, but if you have any additional requirements, you can always search in forums like Stackoverflow or check the help for each command, which consists of placing the command name followed by --help. For example, if I want to know the help for the ls command, just run ls --help in the Terminal.\n\n\n\n\n\n\nUpper and lower case\n\n\n\nAs in R or Python, the use of upper or lower case when indicating an option does matter. For example, ls -D is not equivalent to ls -d, so be carefull.\n\n\n\nBrowsing within folders\n\nCommand: cd\nUsage: cd path/folder\n\nTo indicate a previous position (folder), you will use the statement .. as follows: ../path/folder1 (this indicates that there is a folder called path from the folder where you are, and that that has a folder called folder1 as well).\n\n\nCreate a folder\n\nCommand: mkdir\nUsage: mkdir path/folder\n\n\n\nGet the content of a folder as a list\n\nCommand: ls\nUsage: ls path/folder/\n\nMain options:\n\n--all (o -a): Displays all files and subfolders, including those protected (hidden) by the system.\n\n\n\nGenerate a list of files/folders and display the size of each item\n\nCommand: du\nUsage: du path/to/file.csv o du path/to/folder\n\nMain options:\n\n--human-readable (o -h): changes the units dynamically to avoid displaying all Kb. This is especially useful when you have large objects (subfolders or files).\n--summary (o -s): displays a summary table, i.e. it only includes the subfolders and files present at the first search level. This is useful when we just want to take a quick look and avoid displaying a complete listing of ALL internal subfolders.\n\nIf I want to get a list of all the files and folders inside a folder with their respective sizes (the three options are equivalent):\n\ndu ruta/de/folder/* --human-readable --summarize\ndu ruta/de/folder/* -h -s\ndu ruta/de/folder/* -hs\n\n\n\nCopy-paste\nFor this, the simplest way is through the cp command and making use of the navigation commands cited in this post (e.g. .. to indicate a previous folder). The basic syntax is the following: cp path/origin /path/destination, but there are different possible cases:\n\nCopy a file into the same folder, but with a different name (create duplicate): cp file1.csv file1-dup.csv.\nCopy a file to another folder: cp path/file1.csv path/destination.\nCopy more than one file to another folder: cp path/file1.csv path/file2.csv folder/destination\nCopy a folder to another folder: cp path/folder1 path/folder2 --recursive or cp path/folder1 path/folder2 -r.\n\n\n\n\n\n\n\nNote\n\n\n\nBy default, cp will overwrite any file with the same name. To avoid this, it is possible to add the -n option as follows: cp path/from/file1.csv path/destination -n.\n\n\n\n\nCut-paste (and also rename)\nIt will be very similar to the above, but through the mv command:\n\nRename a file (within the same folder): mv file1.csv file2.csv\nMove a file to another folder: mv path/file1.csv path/to/destination\nMove one file to another folder: mv path/file1.csv path/file2.csv path/destination\nMove one folder to another folder: mv path/old/folder path/new/folder\n\n\n\nDelete\nFor this, we will use the rm command as follows:\n\nDelete a file: rm path/to/file.csv\nDelete a folder (and all its contents): rm path/to/folder -r\n\n\n\n\n\n\n\nNo turning back\n\n\n\nWhile inside Terminal it is always possible to cancel a command using the shortcut Ctrl+C (or Cmd+C on MacOS), once the rm command completes its work, there is no way to revert the deletion or recover it from a recycle garbage can, so be very careful when using it.\n\n\n\n\nDisplay current processes\n\nCommand: top\n\nWhen you run it, it will show in interactive mode in Terminal the processes that are running, as well as the resources used by each of them (basically like a Task Manager). To exit this interactive mode, just press the q key.\n\n\nStop a process\nIf we want to force the closing or the cancellation of a process already started, we can use the shortcut Ctrl+C (or Cmd+C in MacOS). It is important to keep in mind that forcing the closing of a process that had in progress the handling of files or folders (creation, copy, etc.) can leave the generated files unusable.\n\n\nViewing a plain text file\nBy default, there are two tools available from Terminal: vi and nano. The syntax for their execution is as simple as vi path/file1.txt or nano path/file1.txt, where file1.txt can be any plain text file (e.g. an R or Python script). The navigation shortcuts within each of these environments are different, but documentation is abundant on the Internet. Choose the one you like best.\n\n\n\n[ES] Principales comandos en Terminal de marbec-gpu\nLo primero que debemos tener en cuenta es que marbec-gpu lleva instalado Ubuntu, por lo que los comandos listados a continuación serán los mismos que se usan en dicho SO. En este artículo se mostrará una descripción de los principales modos de uso para cada comando, pero si usted tiene algún requerimiento adicional, siempre puede buscar en foros como Stackoverflow o revisar la ayuda de cada comando, que consiste en colocar el nombre del comando seguido de --help. Por ejemplo, si deseo conocer la ayuda del comando ls, bastará con ejecutar ls --help en la Terminal.\n\n\n\n\n\n\nMayúsculas y minúsculas\n\n\n\nAl igual que en R o Python, el uso de mayúsculas o minúsculas al momento de indicar una opción sí importa. Por ejemplo, ls -D no equivale a ls -d, por lo que se debe tener cuidado.\n\n\n\nNavegar entre carpetas\n\nComando: cd\nModo de uso: cd ruta/carpeta\n\nPara indicar que se desea ir a una posición (carpeta) anterior, se utilizará el statement .. de la siguiente manera: ../ruta/carpeta1 (esto indica que a partir de la carpeta en donde nos encontramos, en la carpeta anterior hay una carpeta llamada ruta que a su vez tiene una llamada carpeta1).\n\n\nCrear una carpeta\n\nComando: mkdir\nModo de uso: mkdir ruta/carpeta\n\n\n\nGenerar un listado de archivos\n\nComando: ls\nModo de uso: ls ruta/folder\n\nPrincipales opciones:\n\n--all (o -a): Muestra todos los archivos y subcarpetas, incluyendo aquellos protegidos (ocultos) por el sistema.\n\n\n\nGenerar un listado de archivos/carpetas mostrando el tamaño de cada elemento\n\nComando: du\nModo de uso: du ruta/archivo-folder.csv\n\nPrincipales opciones:\n\n--human-readable (o -h): cambia las unidades dinámicamente para evitar mostrar todo Kb. Esto es especialmente útil cuando se tiene objetos (subcarpetas o archivos) de gran tamaño.\n--summary (o -s): muestra una tabla resumida, i.e. solo incluye las subcarpetas y archivos presentes en el primer nivel de búsqueda. Esto es útil cuando solo queremos echar un vistazo rápido y evitar que muestre un listado completo de TODAS las subcarpetas internas.\n\nSi deseo obtener un listado de todos los archivos y carpetas dentro de un folder con sus respectivos tamaños (las tres opciones son equivalentes):\n\ndu ruta/de/folder/* --human-readable --summarize\ndu ruta/de/folder/* -h -s\ndu ruta/de/folder/* -hs\n\n\n\nCopiar-pegar\nPara esto, la manera más sencilla es a través del comando cp y haciendo uso de los comandos de navegación citados en este post (e.g. .. para indicar una carpeta anterior). La sintaxis básica es la siguiente: cp ruta/de/origen ruta/de/destino, pero existen diferentes casos posibles:\n\nCopiar un archivo dentro de la misma carpeta, pero con un nombre distinto (crear duplicado): cp archivo1.csv archivo1-dup.csv\nCopiar un archivo hacia otra carpeta: cp ruta/de/archivo1.csv carpeta/de/destino\nCopiar más de un archivo hacia otra carpeta: cp ruta/de/archivo1.csv ruta/de/archivo2.csv carpeta/de/destino\nCopiar una carpeta en otra carpeta: cp ruta/de/carpeta1 ruta/de/carpeta2 --recursive o cp ruta/de/carpeta1 ruta/de/carpeta2 -r\n\n\n\n\n\n\n\nNote\n\n\n\nPor defecto, cp sobreescribirá cualquier archivo con el mismo nombre. Para evitarlo, es posible añadir la opción -n del siguiente modo: cp ruta/de/archivo1.csv ruta/de/destino -n\n\n\n\n\nCortar-pegar (y también renombrar)\nSerá muy similar a lo anterior, pero a través del comando mv:\n\nRenombrar un archivo (dentro de la misma carpeta): mv archivo1.csv archivo2.csv\nMover un archivo hacia otra carpeta: mv ruta/de/archivo1.csv carpeta/de/destino\nMover más de un archivo hacia otra carpeta: mv ruta/de/archivo1.csv ruta/de/archivo2.csv carpeta/de/destino\nMover una carpeta hacia otra carpeta: mv ruta/antigua/carpeta ruta/nueva/carpeta\n\n\n\nBorrar\nPara esto, utilizaremos el comando rm de la siguiente manera:\n\nBorrar un archivo: rm ruta/de/archivo.csv\nBorrar una carpeta (y todo su contenido): rm ruta/de/carpeta -r\n\n\n\n\n\n\n\nNo hay vuelta atrás\n\n\n\nSi bien dentro de Terminal siempre es posible cancelar una orden usando el atajo Ctrl+C (o Cmd+C en MacOS), una vez que se ejecuta el comando rm y éste culmina su trabajo, no hay manera de revertir lo borrado ni recuperarlo desde alguna papelera de reciclaje, así que ten mucho cuidado al usarlo.\n\n\n\n\nVisualizar procesos en curso\n\nComando: top\n\nAl ejecutarlo, se mostrará en modo interactivo en Terminal los procesos que se están ejecutando, así como los recursos utilizados por cada uno de ellos (básicamente como un Administrador de tareas). Para salir de este modo interactivo, basta con pulsar la tecla q.\n\n\nDetener la ejecución de un proceso\nSi queremos forzar el cierre o la cancelación de un proceso ya iniciado, podemos utilizar el atajo Ctrl+C (o Cmd+C en MacOS). Es importante tener en cuenta que forzar el cierre de un proceso que tenía en marcha el manejo de archivos o carpetas (creación, copia, etc.) puede dejar inutilizables los archivos generados.\n\n\nVisualizar un archivo de texto plano\nPor defecto, desde Terminal existen dos herramientas disponibles: vi y nano. La sintaxis para su ejecución es tan sencilla como vi ruta/archivo1.txt o nano ruta/archivo1.txt, en donde archivo1.txt puede ser cualquier archivo de texto plano (e.g. un script en R o Python). Los atajos de navegación dentro de cada uno de esos entornos sí son distintos, pero la documentación es muy abundante en Internet. Elige el que te agrade más."
  },
  {
    "objectID": "blog/about-this-website/about-this-website.html",
    "href": "blog/about-this-website/about-this-website.html",
    "title": "Developing Beneath the surface",
    "section": "",
    "text": "The first thing that came to mind was “how can I develop a page that I can leave as a reference for those who want to contact me in a professional setting?” and “through what medium can I share those ideas, small works or personal experiences that I believe could be useful for other professionals in my field?”. Well, there are many options around (social media, podcasts, TikTok, etc.). This first decision was not difficult, as I am not particularly characterized by my charisma on social networks, so I decided to opt for writing a blog. However, here the decision-making process did get a bit complicated, as there are many platforms available: Wordpress, Netlify, Gitlab pages, Medium, among others. Each one offers different advantages and potential, but my decision was based above all on the familiarity of use of the Github and Quarto platforms. I decided on Github pages.\n\n\n\nGithub Pages is a free static website hosting service that allows you to publish HTML content directly from a GitHub repository. This platform offers multiple advantages:\n\nIt’s free!: You don’t need to pay for a web hosting service, just have a (free) GitHub account.\nEasy to use: Uploading your HTML, CSS, and JavaScript files to GitHub is very simple.\nDirect integration with GitHub: This becomes VERY important if you already use GitHub (as was my case) for your code projects.\nVersioning: GitHub Pages keeps a history of all the changes you make to your website, so if something goes wrong you can always go back to a previous version of your repository (page).\nSecure: GitHub Pages uses HTTPS to protect your website.\nFast: For a few years now, Microsoft has bought GitHub and therefore its services use an extensive global network of servers to deliver your website to users around the world.\nScalable: GitHub Pages can handle any amount of traffic, so your website can grow smoothly. Although a personal/professional blog is not expected to have very high traffic peaks, it is always good to know that this support exists.\nSEO optimized: GitHub Pages is optimized for search engines, which will help your website appear in the results of major web search engines.\n\nIn the end, Github pages was the hosting option that I found most attractive. However, there are multiple ways to upload content, from different development platforms that involve the use of programming languages (e.g. Javascript) or markup, such as markdown or Quarto. Once again, my historical experience weighed more and I decided to use Quarto.\n\n\n\nQuarto is an open-source scientific document publishing platform developed by the POSIT (formerly RStudio) team. It is based on the R Markdown format and extends it with new features and functionalities to create richer and more interactive documents. It implements a more powerful preprocessing system than R Markdown and supports additional programming languages such as Python and Julia, expanding the possibilities for analysis and visualization.\nFor the past few years, I have been using Quarto not only for writing simple R reports, but also for the complete composition of scientific articles (one of them with a format submitted directly from the .docx output obtained in Quarto), as well as the development of interactive websites through the Quarto-Shiny duo.\n\n\n\nI Didn’t Have to Start from Scratch. Fortunately, there are many resources available online, but I will briefly summarize the main links I used:\n\nCreate the website hosted on Github pages, prepare it for content management with Quarto and to work from RStudio: The first steps to follow are very well explained in the video by Melissa Van Bussel (link). Highly recommended, although it assumes that we know how to handle Git-bash and that we have a token well configured for our PC. I will put these last details at the end of this article.\n\n\n\nEstablish an outline of what we are going to publish: Once we have successfully configured our website, it is time to take pen and paper and outline what content we want to share and what the logic will be for organizing that content into sections. While this part is very personal, since it will not be the same to diagram a page that only aims to serve as a professional reference (that is, an interactive resume) to that of a freelancer who wants to show their main projects and/or services offered, you don’t need to start from scratch either. You can review examples of pages from other creators (researchers, reporters, bloggers, graphic artists, etc.) and be inspired by their designs. Also, you can review examples of page structures that use Github pages (link). Remember, everything must ALWAYS start with the type of content you plan to place.\nStart writing: OK, this is not a scientific article and there is much more freedom to fill in the different sections; however, always remember to take into account the basic writing criteria (from general to specific), be clear and careful when choosing the type of language (based on the type of audience you expect to read you) and, once again, review examples. Of course, these days AI text generation platforms can be of great help, but we should not delegate the entire burden (i.e. no copy-paste) to them without first reading and corroborating the information they return to us. At this point, the following articles were very useful to me:\n\nCreate your website with Quarto: complete tutorial and template link: https://www.marvinschmitt.com/blog/website-tutorial-quarto/.\nCreating your personal website with Quarto link: https://ucsb-meds.github.io/creating-quarto-websites/.\nCreating a website link: https://quarto.org/docs/websites/.\n\nEstablish an order: Once we have finished and published a first article, everything will be simpler in technical terms since you will discover that there are multiple reference sources available."
  },
  {
    "objectID": "blog/about-this-website/about-this-website.html#the-idea",
    "href": "blog/about-this-website/about-this-website.html#the-idea",
    "title": "Developing Beneath the surface",
    "section": "",
    "text": "The first thing that came to mind was “how can I develop a page that I can leave as a reference for those who want to contact me in a professional setting?” and “through what medium can I share those ideas, small works or personal experiences that I believe could be useful for other professionals in my field?”. Well, there are many options around (social media, podcasts, TikTok, etc.). This first decision was not difficult, as I am not particularly characterized by my charisma on social networks, so I decided to opt for writing a blog. However, here the decision-making process did get a bit complicated, as there are many platforms available: Wordpress, Netlify, Gitlab pages, Medium, among others. Each one offers different advantages and potential, but my decision was based above all on the familiarity of use of the Github and Quarto platforms. I decided on Github pages."
  },
  {
    "objectID": "blog/about-this-website/about-this-website.html#github-pages",
    "href": "blog/about-this-website/about-this-website.html#github-pages",
    "title": "Developing Beneath the surface",
    "section": "",
    "text": "Github Pages is a free static website hosting service that allows you to publish HTML content directly from a GitHub repository. This platform offers multiple advantages:\n\nIt’s free!: You don’t need to pay for a web hosting service, just have a (free) GitHub account.\nEasy to use: Uploading your HTML, CSS, and JavaScript files to GitHub is very simple.\nDirect integration with GitHub: This becomes VERY important if you already use GitHub (as was my case) for your code projects.\nVersioning: GitHub Pages keeps a history of all the changes you make to your website, so if something goes wrong you can always go back to a previous version of your repository (page).\nSecure: GitHub Pages uses HTTPS to protect your website.\nFast: For a few years now, Microsoft has bought GitHub and therefore its services use an extensive global network of servers to deliver your website to users around the world.\nScalable: GitHub Pages can handle any amount of traffic, so your website can grow smoothly. Although a personal/professional blog is not expected to have very high traffic peaks, it is always good to know that this support exists.\nSEO optimized: GitHub Pages is optimized for search engines, which will help your website appear in the results of major web search engines.\n\nIn the end, Github pages was the hosting option that I found most attractive. However, there are multiple ways to upload content, from different development platforms that involve the use of programming languages (e.g. Javascript) or markup, such as markdown or Quarto. Once again, my historical experience weighed more and I decided to use Quarto."
  },
  {
    "objectID": "blog/about-this-website/about-this-website.html#quarto",
    "href": "blog/about-this-website/about-this-website.html#quarto",
    "title": "Developing Beneath the surface",
    "section": "",
    "text": "Quarto is an open-source scientific document publishing platform developed by the POSIT (formerly RStudio) team. It is based on the R Markdown format and extends it with new features and functionalities to create richer and more interactive documents. It implements a more powerful preprocessing system than R Markdown and supports additional programming languages such as Python and Julia, expanding the possibilities for analysis and visualization.\nFor the past few years, I have been using Quarto not only for writing simple R reports, but also for the complete composition of scientific articles (one of them with a format submitted directly from the .docx output obtained in Quarto), as well as the development of interactive websites through the Quarto-Shiny duo."
  },
  {
    "objectID": "blog/about-this-website/about-this-website.html#the-content",
    "href": "blog/about-this-website/about-this-website.html#the-content",
    "title": "Developing Beneath the surface",
    "section": "",
    "text": "I Didn’t Have to Start from Scratch. Fortunately, there are many resources available online, but I will briefly summarize the main links I used:\n\nCreate the website hosted on Github pages, prepare it for content management with Quarto and to work from RStudio: The first steps to follow are very well explained in the video by Melissa Van Bussel (link). Highly recommended, although it assumes that we know how to handle Git-bash and that we have a token well configured for our PC. I will put these last details at the end of this article.\n\n\n\nEstablish an outline of what we are going to publish: Once we have successfully configured our website, it is time to take pen and paper and outline what content we want to share and what the logic will be for organizing that content into sections. While this part is very personal, since it will not be the same to diagram a page that only aims to serve as a professional reference (that is, an interactive resume) to that of a freelancer who wants to show their main projects and/or services offered, you don’t need to start from scratch either. You can review examples of pages from other creators (researchers, reporters, bloggers, graphic artists, etc.) and be inspired by their designs. Also, you can review examples of page structures that use Github pages (link). Remember, everything must ALWAYS start with the type of content you plan to place.\nStart writing: OK, this is not a scientific article and there is much more freedom to fill in the different sections; however, always remember to take into account the basic writing criteria (from general to specific), be clear and careful when choosing the type of language (based on the type of audience you expect to read you) and, once again, review examples. Of course, these days AI text generation platforms can be of great help, but we should not delegate the entire burden (i.e. no copy-paste) to them without first reading and corroborating the information they return to us. At this point, the following articles were very useful to me:\n\nCreate your website with Quarto: complete tutorial and template link: https://www.marvinschmitt.com/blog/website-tutorial-quarto/.\nCreating your personal website with Quarto link: https://ucsb-meds.github.io/creating-quarto-websites/.\nCreating a website link: https://quarto.org/docs/websites/.\n\nEstablish an order: Once we have finished and published a first article, everything will be simpler in technical terms since you will discover that there are multiple reference sources available."
  },
  {
    "objectID": "blog/about-this-website/about-this-website.html#la-idea",
    "href": "blog/about-this-website/about-this-website.html#la-idea",
    "title": "Developing Beneath the surface",
    "section": "La idea",
    "text": "La idea\nLo primero que llegó a mi mente fue «¿de qué manera puedo desarrollar una página en que pueda dejar como referencia para aquellos que quisieran contactar conmigo en un ambiente profesional?» y «¿desde qué medio puedo compartir aquellas ideas, pequeños trabajos o experiencias personales que creo que podrían resultar de utilidad para otros profesionales en mi rubro?». Bueno, existen muchas opciones alrededor (redes sociales, podcast, TikTok, etc.). Esta primera decisión no fue difícil, pues no me caracterizo particularmente por mi carisma en redes, así que decidí optar por escribir un blog. Sin embargo, aquí la toma de decisiones sí se complicó un poco, pues existen muchas plataformas disponibles: Wordpress, Netlify, Gitlab pages, Medium, entre others. Cada una plantea ventajas y potencialidades distintas, pero mi decisión se basó sobre todo en la familiaridad de uso de las plataformas Github y Quarto. Me decidí por Github pages."
  },
  {
    "objectID": "blog/about-this-website/about-this-website.html#github-pages-1",
    "href": "blog/about-this-website/about-this-website.html#github-pages-1",
    "title": "Developing Beneath the surface",
    "section": "Github pages",
    "text": "Github pages\nGithub pages es un servicio gratuito de alojamiento de sitios web estáticos que permite publicar contenido HTML directamente desde un repositorio de GitHub. Esta plataforma ofrece múltiples ventajas:\n\nGratuito: No necesitas pagar por un servicio de alojamiento web, solo tener una cuenta de GitHub (gratuita).\nFácil de usar: Subir tus archivos HTML, CSS y JavaScript a GitHub es muy sencillo.\nIntegración directa con GitHub: Esto se hace MUY importante si ya usas GitHub (como fue mi caso) para tus proyectos de código.\nVersionado: GitHub Pages guarda un historial de todos los cambios que realices en tu sitio web, por lo que si algo sale mal siempre puedes volver a una versión anterior de tu repositorio (página).\nSeguro: GitHub Pages utiliza HTTPS para proteger tu sitio web.\nRápido: Desde hace unos años, Microsoft compró GitHub y por tanto sus servicios utilizan una extensa red global de servidores para entregar tu sitio web a los usuarios de todo el mundo.\nEscalable: GitHub Pages puede manejar cualquier cantidad de tráfico, por lo que tu sitio web puede crecer sin problemas. Aunque de un blog personal/profesional no se espera tener picos de tráfico muy altos, siempre es bueno saber que existe este respaldo.\nOptimizado para SEO: GitHub Pages está optimizado para los motores de búsqueda, lo que ayudará a que nuestro sitio web aparezca en los resultados de los principales buscadores web.\n\nAl final, Github pages fue la opción de alojamiento que me resultó más atractiva. Sin embargo, existen múltiples maneras de subir contenido, desde diferentes plataformas de desarrollo que involucran el uso de lenguajes de programación (e.g. Javascript) o de marcado, como markdown o Quarto. Una vez más, mi experiencia histórica pesó más y me decanté por el uso de Quarto."
  },
  {
    "objectID": "blog/about-this-website/about-this-website.html#quarto-1",
    "href": "blog/about-this-website/about-this-website.html#quarto-1",
    "title": "Developing Beneath the surface",
    "section": "Quarto",
    "text": "Quarto\nQuarto es una plataforma de publicación de documentos científicos de código abierto desarrollada por el equipo de POSIT (ex RStudio). Se basa en el formato R Markdown y lo amplía con nuevas características y funcionalidades para crear documentos más ricos e interactivos. Implementa un sistema de preprocesamiento más potente que R Markdown y soporta lenguajes de programación adicionales como Python y Julia, ampliando las posibilidades de análisis y visualización.\nDesde hace unos pocos años, he venido utilizando Quarto no solo para la redacción de reportes sencillos en R, sino inclusive para la composición completa de artículos científicos (uno de ellos con formato sometido directamente desde la salida en .docx obtenida en Quarto), así como el desarrollo de webs interactivas a través de la dupla Quarto-Shiny."
  },
  {
    "objectID": "blog/about-this-website/about-this-website.html#el-contenido",
    "href": "blog/about-this-website/about-this-website.html#el-contenido",
    "title": "Developing Beneath the surface",
    "section": "El contenido",
    "text": "El contenido\nNo tuve que empezar desde cero. Afortunadamente, hay mucho material allá afuera, pero resumiré brevemente los principales links que utilicé:\n\nCrear la website alojada en Github pages, preparaela para el manejo de contenido con Quarto y para trabajar desde RStudio: Los primeros pasos a seguir están muy bien explicados en el vídeo de Melissa Van Bussel (link). Muy recomendable, aunque parte bajo el supuesto de que conocemos cómo manejar Git-bash y de que tenemos bien configurado un token para nuestra PC. Estos últimos detalles los colocaré al final de este artículo.\n\n\n\nEstablecer un esquema de lo que vamos a publicar. Una vez que hayamos logrado configurar correctamente nuestra web, sigue el turno de tomar lápiz y papel y esquematizar qué contenido deseamos compartir y cuál será la lógica para ordenar dicho contenido en secciones. Si bien esta parte es muy personal, ya que no será lo mismo diagramar una página que solo tiene como objetivo servir de referencia profesional (es decir, un CV interactivo) a la de un freelancer que desea mostrar sus principales proyectos y/o servicios ofrecidos, no necesitas ir desde cero tampoco. Puedes revisar ejemplos de páginas de otros creadores (investigadores, reporteros, bloggers, artistas gráficos, etc.) e inspirarte en sus diseños. Así también, puedes revisar ejemplos de estructuras de páginas que usan Github pages (link). Recuerda, todo debe partir SIEMPRE del tipo de contenido que planeas colocar.\nEmpezar a escribir. OK, esto no es un artículo científico y hay mucha más libertad para rellenar las distintas secciones; no obstante, recuerda siempre tener en cuenta los criterios básicos de redacción (de lo general a lo específico), ser claro y cuidadoso al elegir el tipo de lenguaje (con base en el tipo de público que esperas que te lea) y, una vez más, revisar ejemplos. Por supuesto, en estos días las plataformas de IA para generación de texto pueden resultar de gran ayuda, pero no debemos delegarles toda la carga (i.e. nada de copiar-pegar) sin antes leer corroborar la información que nos devuelven. En este punto, me fueron de mucha utilidad los siguientes artículos:\n\nCrear tu website con Quarto: tutorial completo y plantilla link.\nCreando tu website personal con Quarto link.\nCreando un website link.\n\nEstablecer un orden. Una vez que hayamos culminado y publicado un primer artículo, todo irá siendo más simple en términos técnicos ya que descubrirás que existen múltiples fuentes de referencia disponibles."
  },
  {
    "objectID": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html",
    "href": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html",
    "title": "Let’s working with marbec-gpu",
    "section": "",
    "text": "Image credits: Андрей Сизов at Unplash"
  },
  {
    "objectID": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#lets-tidy-up-a-bit",
    "href": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#lets-tidy-up-a-bit",
    "title": "Let’s working with marbec-gpu",
    "section": "Let’s tidy up a bit",
    "text": "Let’s tidy up a bit\n\nCreating a working directory\nAs when working with RStudio locally (i.e. on our PC), it is recommended to clearly define our working directory. This is extremely important because any process we run (either from RStudio or Terminal) will use that directory as a reference to find input files, output files or even other scripts.\nFor our case, we have created a folder called mgpu-examples/ where there is a subfolder called code/. The creation of folders in marbec-data can be done directly from the web interface (by clicking on File station and then using the Create folder button), the command mkdir, but we can also copy-paste the elements already existing in our PC into the working folder.\n\n\nCreating an RStudio project\nThe following is NOT mandatory, but very useful, especially when working with RStudio and that is to create an RStudio project. To do this, we will go to File and then New Project.\n\nThen, in the window that appears, click on Existing directory, then on Browse and click on the folder that we have defined as our working directory (in our case, mgpu-examples/). Then, OK and finally click on the Create Project button. Rstudio will flicker a little bit and then will show us the same window, but inside the set project. The easiest way to check that the project has been created in the correct folder (mgpu-examples/ in our case) is to verify that right in the Console panel, to the right of the R version, appears only the path of our main folder (and not any of the subfolders, e.g. mgpu-examples/code/ or mgpu-examples/inputs/).\n\n\n\n\n\n\n\nJust before to say hello\n\n\n\nmarbec-gpu incorporates the possibility of working with RStudio (Server); however, this interface should be used ONLY to PREPARE our scripts before being executed using all the power of our server. In other words, within the RStudio environment we will be able to load not so big files and perform basic operations, but at no time should we execute a complex (heavy) process from there, but from Terminal."
  },
  {
    "objectID": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#hello-world-simple-examples",
    "href": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#hello-world-simple-examples",
    "title": "Let’s working with marbec-gpu",
    "section": "Hello world! (simple examples)",
    "text": "Hello world! (simple examples)\n\nExample 1-1\nWe will start with the simplest: create a script in R and print the (very famous) “Hello world!” message.\n\nWe will start by opening an RStudio session from the JupyterLab environment (if you want to know how to get there, check the post of Introduction to marbec-gpu).\nOnce inside the RStudio environment, we will create a new script (File -&gt; New file -&gt; R script) which will contain a single line:\n\n\nprint(\"Hello world and hello marbec-gpu!\")\n\n\nThen, we will save that script with the name code/ex1-1.R (code/ refers to a subfolder created previously inside the working directory of our project in RStudio).\nNow comes the interesting part, inside our browser, we must go back to the Launcher tab and open a Terminal window (clicking on the corresponding icon).\nBy default, Terminal will open a session in the local folder assigned to our user. From there, we must get to the folder we have set as working directory; that is, the folder that our script will recognize as working directory (whether we have decided to use RStudio or not to create it or create a project inside it). Assuming that our working directory is the mgpu-examples/ folder, we must reach it using the cd command:\n\n\ncd mgpu-examples/\n\n\n\n\n\n\n\nHow do we know that we have arrived at the correct folder?\n\n\n\nFirst, the prompt will indicate the name of the folder in which it is located.\n\nIn addition, we can run the ls command which will show the subfolders and files inside the folder we have reached. If everything matches, then we did well.\n\n\n\n\nNext, we execute the following command in the Terminal: Rscript code/ex1-1.R and the result should be just what would be shown in a usual R session.\n\n\n\n\nExample 1-2\nIn this next example, we will show a script that generates and saves files in our working directory where previously, we will create two new folders (figures/ and outputs/) through the mkdir command as follows:\n\nmkdir figures/ outputs/\n\n\n\n\n\n\n\nNote\n\n\n\nWithin the Terminal environment, it is not possible to observe graphics interactively (as in RStudio), so if you want to keep any figure, you must always include the code to save it within the script you execute. Depending on the graphical environment, we can use functions such as png, bmp, jpeg, pdf (for graphics environment), or ggsave (for ggplot2 environment).\n\n\n\nNow, let’s go to RStudio to create the following script and save it in code/ex1-2.R:\n\n\n# Print mtcars\nprint(mtcars)\n\n# Export mtcars as a csv\nwrite.csv(x = mtcars, file = \"outputs/mtcars.csv\")\n \n# Create and save a scatterplot\npng(filename = \"figures/fig_1-1.png\")\n\nplot(x = mtcars$mpg, y = mtcars$disp, \n     xlab = \"Miles per (US) gallon\", ylab = \"Displacement (cu.in.)\")\n\ndev.off()\n\n\nNext, we go back to the Terminal environment and run our new script with the command Rscript code/ex1-2.R. Immediately, the mtcars table will be displayed as that is what the first line of our script commands.\n\n\n\nHowever, if we run the ls command in Terminal for the figures/ and outputs/ folders, we will see that the two files we ordered to be created inside our script appear.\n\n\n\nIf the files created are the ones we expect to collect from our analysis, we can download them through Filezilla (see the corresponding post).\n\n\n\n\n\n\n\nPreviewing figures\n\n\n\nWhile it is not possible to preview figures in Terminal or JupyterLab because they do not have an image viewer, it is possible to do so from the marbec-data web environment. However, this is a basic viewer and only available for the most common file types."
  },
  {
    "objectID": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#hello-universe-parallel-process",
    "href": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#hello-universe-parallel-process",
    "title": "Let’s working with marbec-gpu",
    "section": "Hello universe! (parallel process)",
    "text": "Hello universe! (parallel process)\n\nExample 2-1: A loop in a single core\n\nWe will start by creating a script (which we will save as code/ex2-1.R) containing a simple loop that generates 20 100x100 arrays with random values and saves them in separate csv files inside the outputs/ex2-rndmats/ folder (remember to create that folder beforehand using mkdir):\n\n\n# Setting number of rows and columns\nrow_n &lt;- 100\ncol_n &lt;- 100\n\nfor(i in seq(20)){\n  # Create random matrix\n  rndMat &lt;- matrix(data = runif(n = row_n*col_n), nrow = row_n, ncol = col_n)\n  \n  # Save matrix\n  write.csv(x = rndMat, \n            file = sprintf(fmt = \"outputs/ex2-rndmats/mat_%02d.csv\", i), \n            row.names = FALSE)\n  \n  # Print a message at the end of each step\n  cat(sprintf(fmt = \"Matrix %02d finished!\\n\", i))\n}\n\n\nNow, we will run our script in Terminal (with the command Rscript code/ex2-1.R) and we will observe that everything went well if the messages at the end of each step of the loop are displayed correctly and also if when we run the command ls on the target folder we see the files created:\n\n\n\n\n\n\n\n\nRun a small example first\n\n\n\nBeing already in a real execution, it is highly recommended always to try with a small example that allows us to corroborate that our script goes well BEFORE to pull out all the stops trying to execute the heavy process. In addition, if our script returns figures or files, executing a small corroboration script allows us to quickly check if the generated files are consistent with what we expect to obtain.\n\n\n\n\nExample 2-2: A loop on multiple cores\n\nStarting from the previous example, we will convert our script into one that executes the processes in parallel. For this we will take advantage of the tools of the packages foreach and doParallel. Note that the names of the files of this script will begin with the letters mc_ to be able to recognize them with respect to those obtained in the previous example:\n\n\n# Setting number of rows and columns\nrow_n &lt;- 100\ncol_n &lt;- 100\n\nrequire(foreach)\nrequire(doParallel)\n\n# Registering cluster\ncl &lt;- makeCluster(spec = 20)\nregisterDoParallel(cl = cl)\n\n# Run multithread process\nout &lt;- foreach(i = seq(20), .inorder = FALSE) %dopar% {\n# Create random matrix\n  rndMat &lt;- matrix(data = runif(n = row_n*col_n), nrow = row_n, ncol = col_n)\n  \n  # Save matrix\n  write.csv(x = rndMat, \n            file = sprintf(fmt = \"outputs/ex2-rndmats/mc_mat_%02d.csv\", i), \n            row.names = FALSE)\n  \n  NULL\n}\n\n# Finish cluster\nstopCluster(cl)\n\n\nNow, we will run our script in Terminal (with the command Rscript code/ex2-2.R) and we will observe that everything has gone well if when executing the command ls on the target folder we see the created files:\n\n\n\n\n\n\n\n\nNote\n\n\n\nA couple of things:\n\nIn the script of the second example, foreach is assigned to an object (out) which will receive the last object generated within each step of the loop. If you only want to get files to be exported (figures, tables, NetCDF, etc.), be sure to leave a NULL in the last line of the loop. On the other hand, if you want to get an object and it is placed in that position, foreach will compile it using the list function, i.e. the final object (out) will be a list that will have as many levels as there are steps in the loop. Also, it is important to note that internally foreach runs a separate small R session so it is necessary to indicate the additional packages required through the .packages argument (see the following example).\nThe argument spec = 20 inside makeCluster refers to the amount of threads that will be used to execute the loop. Remember that one of the options when creating your server in marbec-gpu was to choose the amount of CPUs (2, 4, 8, 16, 32…)? Well, it is precisely with this argument where you will indicate that amount of logical cores. Remember that another important aspect is the RAM. At a given time each process running within each thread will have to load everything that a single simple process would need. In other words, if in a single core process, in each step of our loop we have to load 5 NetCDF files that occupy 5 GB in RAM, if we run that process in multicore and we define spec = 40, at a given moment we will have to load 5GBx40 (200 GB) in RAM simultaneously. So not only you must choose well the configuration of your server (regarding the script you plan to run), but also an approximate of what is consumed in each independent process, in order not to saturate your server. marbec-gpu is great, but it has its limits."
  },
  {
    "objectID": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#un-poco-de-orden",
    "href": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#un-poco-de-orden",
    "title": "Let’s working with marbec-gpu",
    "section": "Un poco de orden",
    "text": "Un poco de orden\n\nCreando un directorio de trabajo\nAl igual que cuando se trabaja con RStudio de manera local (i.e. en nuestra PC), se recomienda definiendo claramente nuestro directorio de trabajo. Esto es sumamente importante porque cualquier proceso que ejecutemos (ya sea desde RStudio o Terminal) utilizará ese directorio como referencia para hallar los archivos de entrada, salida o incluso otros scripts.\nPara nuestro caso, hemos creado una carpeta llamada mgpu-examples/ en donde a su vez existen las subcarpetas code/, inputs/, outputs/ y figures/. La creación de carpetas en marbec-data puede hacerse directamente desde la interfaz web (dando click a File station y luego usando el botón Create folder), pero también podemos copiar-pegar los elementos ya existentes en nuestra PC hacia la carpeta de trabajo.\n\n\nCreando un proyecto de RStudio\nLo siguiente NO es obligatorio, pero sí muy útil, sobre todo cuando se trabaja con RStudio y es crear un proyecto de RStudio. Para ello, iremos a File y luego a New Project.\n\nLuego, en la ventana que nos aparece, daremos click a Existing directory, luego a Browse y daremos click a la carpeta que hemos definido como nuestro directorio de trabajo (en nuestro caso, mgpu-examples/). Luego, Aceptar y finalmente en el botón Create Project. Rstudio parpadeará un poco y luego nos mostrará la misma ventana, pero dentro del proyecto establecido. La manera más sencilla de comprobar que el proyecto se ha creado en la carpeta correcta (mgpu-examples/ en nuestro caso) es verificando que justo en el panel de Console, a la derecha de la versión de R, aparezca únicamente la ruta de nuestra carpeta principal (y no alguna de las subcarpetas, e.g. mgpu-examples/code/ o mgpu-examples/inputs/).\n\n\n\n\n\n\n\nAntes de decir hello\n\n\n\nmarbec-gpu incorpora la posibilidad de trabajar con RStudio (Server); sin embargo, esta interfaz deberá utilizarse ÚNICAMENTE para PREPARAR nuestros scripts antes de ser ejecutados utilizando toda la potencia de nuestro server. En otras palabras, dentro del entorno de RStudio podremos cargar archivos no tan grandes y realizar operaciones básicas, pero en ningún momento debemos ejecutar un proceso complejo (pesado) desde ahí, sino desde Terminal."
  },
  {
    "objectID": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#hello-world-ejemplos-sencillos",
    "href": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#hello-world-ejemplos-sencillos",
    "title": "Let’s working with marbec-gpu",
    "section": "Hello world! (ejemplos sencillos)",
    "text": "Hello world! (ejemplos sencillos)\n\nEjemplo 1-1\nIniciaremos con lo más sencillo: crear un script en R e imprimir el (famosísimo) mensaje “Hello world!”.\n\nEmpezaremos abriendo una sesión de RStudio a partir del entorno JupyterLab (si desseas conocer cómo llegar hasta ahí, revisa el post de Introducción a marbec-gpu).\nUna vez dentro del entorno RStudio, crearemos un nuevo script (File -&gt; New file -&gt; R script) el cual contendrá una única línea:\n\n\nprint(\"Hello world and hello marbec-gpu!\")\n\n\nLuego, guardaremos ese script con el nombre code/ex1-1.R (code/ hace referencia a una subcarpeta creada anteriormente dentro del working directory de nuestro proyecto en RStudio).\nAhora viene lo interesante, dentro de nuestro navegador, debemos volver a la pestaña de Launcher y abrir una ventana de Terminal (dando click al ícono correspondiente).\nPor defecto, Terminal abrirá una sesión en la carpeta local asignada a nuestro usuario. Desde ahí, debemos llegar a la carpeta que hemos establecido como working directory; es decir, la carpeta que nuestro script reconocerá como directorio de trabajo (ya sea que hayamos decidido usar RStudio o no para crearla o crear un proyecto dentro de ella). Asumiendo que nuestro working directory es la carpeta mgpu-examples/, debemos llegar a ella utilizando el comando cd:\n\n\ncd mgpu-examples/\n\n\n\n\n\n\n\n¿cómo saber que hemos llegado a la carpeta correcta?\n\n\n\nEn primer lugar, el prompt indicará el nombre de la carpeta en la que se encuentra.\n\nAdemás, podemos ejecutar el comando ls con el que se mostrará las subcarpetas y archivos dentro de la carpeta a donde hemos llegado. Si todo coincide, pues lo hicimos bien.\n\n\n\n\nA continuación, ejecutaremos en la Terminal la siguiente orden: Rscript code/ex1-1.R y el resultado deberá ser que justo lo que se nos mostraría en una sesión habitual de R.\n\n\n\n\nEjemplo 1-2\nEn este siguiente ejemplo, mostraremos un script que genera y guarda archivos en nuestro working directory en donde previamente, crearemos dos carpetas nuevas (figures/ y outputs/) a través del comando mkdir del siguiente modo:\n\nmkdir figures/ outputs/\n\n\n\n\n\n\n\nNote\n\n\n\nDentro del entorno de Terminal, no es posible observar gráficos de forma interactiva (como en RStudio), por lo que si se desea conservar cualquier figura, se deberá incluir siempre el código para guardarla dentro del script que ejecutemos. Dependiendo del entorno gráfico, podemos usar funciones como png, bmp, jpeg, pdf (para entorno graphics), o ggsave (para entorno ggplot2).\n\n\n\nAhora, vamos a RStudio para crear el siguiente script y a guardarlo en code/ex1-2.R:\n\n\n# Print mtcars\nprint(mtcars)\n\n# Export mtcars as a csv\nwrite.csv(x = mtcars, file = \"outputs/mtcars.csv\")\n \n# Create and save a scatterplot\npng(filename = \"figures/fig_1-1.png\")\n\nplot(x = mtcars$mpg, y = mtcars$disp, \n     xlab = \"Miles per (US) gallon\", ylab = \"Displacement (cu.in.)\")\n\ndev.off()\n\n\nSeguidamente, volvemos al entorno de Terminal y ejecutaremos nuestro nuevo script con el comando Rscript code/ex1-2.R. Inmediatamente, se mostrará la tabla de mtcars ya que eso es lo que ordena la primera línea de nuestro script.\n\n\n\nSin embargo, si ejecutamos en Terminal el comando ls para las carpetas figures/ y outputs/, veremos que aparecen los dos archivos que ordenamos crear dentro de nuestro script.\n\n\n\nSi los archivos creados son los que esperamos recolectar de nuestro análisis, podemos descargarlos a través de Filezilla (ver el post correspondiente).\n\n\n\n\n\n\n\nPrevisualizar figuras\n\n\n\nSi bien no es posible obtener una previsualización de figuras en Terminal o JupyterLab ya que estos no cuentan con un visor de imágenes, sí es posible hacerlo desde el entorno web de marbec-data. No obstante, se trata de un visor básico y solo disponible para los tipos de archivos más comunes."
  },
  {
    "objectID": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#hello-universe-procesos-en-paralelo",
    "href": "blog/marbec-gpu-run-process/marbec-gpu-run-process.html#hello-universe-procesos-en-paralelo",
    "title": "Let’s working with marbec-gpu",
    "section": "Hello universe! (procesos en paralelo)",
    "text": "Hello universe! (procesos en paralelo)\n\nEjemplo 2-1: Un bucle en un solo núcleo\n\nEmpezaremos creando un script (que guardaremos como code/ex2-1.R) que contenga un bucle sencillo que genere 20 matrices de 100x100 con valores aleatorios y las guarde en archivos csv distintos dentro de la carpeta outputs/ex2-rndmats/ (recuerda que debes crear previamente esa carpeta usando mkdir):\n\n\n# Setting number of rows and columns\nrow_n &lt;- 100\ncol_n &lt;- 100\n\nfor(i in seq(20)){\n  # Create random matrix\n  rndMat &lt;- matrix(data = runif(n = row_n*col_n), nrow = row_n, ncol = col_n)\n  \n  # Save matrix\n  write.csv(x = rndMat, \n            file = sprintf(fmt = \"outputs/ex2-rndmats/mat_%02d.csv\", i), \n            row.names = FALSE)\n  \n  # Print a message at the end of each step\n  cat(sprintf(fmt = \"Matrix %02d finished!\\n\", i))\n}\n\n\nAhora, ejecutaremos nuestro script en Terminal (con el comando Rscript code/ex2-1.R) y observaremos que todo ha ido bien si los mensajes al final de cada paso del bucle se muestran correctamente y si además al ejecutar el comando ls sobre la carpeta objetivo vemos los archivos creados:\n\n\n\n\n\n\n\n\nSiempre correr un ejemplo pequeño primero\n\n\n\nYa en una ejecución real, lo recomendable es siempre intentar con un ejemplo pequeño que nos permita corroborar que nuestro script va bien ANTES de poner toda la carne en el asador tratando de ejecutar el proceso pesado. Además, si nuestro script devuelve figuras o archivos, ejecutar un script pequeño de corroboración nos permite revisar rápidamente si los archivos generados con coherentes con lo que esperamos obtener.\n\n\n\n\nEjemplo 2-2: Un bucle en múltiples núcleos\n\nPartiendo del ejemplo anterior, convertiremos nuestro script en uno que ejecute los procesos de forma paralela. Para ello aprovecharemos las herramientas de los paquetes foreach y doParallel. Nótese que los nombres de los archivos de este script empezarán con las letras mc_ para poder reconocerlos respecto a los obtenidos en el ejemplo anterior:\n\n\n# Setting number of rows and columns\nrow_n &lt;- 100\ncol_n &lt;- 100\n\nrequire(foreach)\nrequire(doParallel)\n\n# Registering cluster\ncl &lt;- makeCluster(spec = 20)\nregisterDoParallel(cl = cl)\n\n# Run multithread process\nout &lt;- foreach(i = seq(20), .inorder = FALSE) %dopar% {\n# Create random matrix\n  rndMat &lt;- matrix(data = runif(n = row_n*col_n), nrow = row_n, ncol = col_n)\n  \n  # Save matrix\n  write.csv(x = rndMat, \n            file = sprintf(fmt = \"outputs/ex2-rndmats/mc_mat_%02d.csv\", i), \n            row.names = FALSE)\n  \n  NULL\n}\n\n# Finish cluster\nstopCluster(cl)\n\n\nAhora, ejecutaremos nuestro script en Terminal (con el comando Rscript code/ex2-2.R) y observaremos que todo ha ido bien si al ejecutar el comando ls sobre la carpeta objetivo vemos los archivos creados:\n\n\n\n\n\n\n\n\nNote\n\n\n\nEs importante notar un par de cosas:\n\nEn el script del segundo ejemplo, foreach se encuentra asignado a un objeto (out) el cual recibirá el último objeto generado dentro de cada paso del loop. Si lo que se desea es únicamente obtener archivos que se exportarán (figuras, tablas, NetCDF, etc.), hay que asegurarse de dejar un NULL en la última línea dentro del bucle. Por otro lado, si lo que se desea es obtener un objeto y éste se coloca en esa posición, foreach lo compilará utilizando la función list, i.e. el objeto final (out) será una lista que tendrá tantos niveles como pasos haya en el bucle. Así mismo, es importante tener en cuenta que internamente foreach ejecuta una pequeña sesión de R aparte por lo que es necesario indicar los paquetes adicionales requeridos a través del argumento .packages (ver el ejemplo siguiente).\nEl argumento spec = 20 dentro de makeCluster hace referencia a la cantidad de hilos de proceso que se utilizarán para ejecutar el bucle, ¿recuerdas que una de las opciones al momento de crear tu server en marbec-gpu era elegir la cantidad de CPUs (2, 4, 8, 16, 32…)? Bueno, pues es justamente con este argumento en donde indicarás esa cantidad de nucleos lógicos. Recuerda que otro aspecto importante es la RAM. En un momento determinado cada proceso corriendo dentro de cada hilo tendrá que cargar todo lo que necesitaría un solo proceso simple. Dicho de otro modo, si en un proceso de núcleo simple, en cada paso de nuestro bucle se tiene que cargar 5 archivos NetCDF que ocupan 5 GB en RAM, si ejecutamos ese proceso en multinúcleo y definimos spec = 40, en un momento se tendrán que cargar 5GBx40 (200 GB) en RAM en simultáneo. Así que no solo debes elegir bien la configuración de tu servidor (respecto al script que planeas ejecutar), sino también un aproximado de lo que se consume en cada proceso independiente, con el fin de no saturar tu servidor. marbec-gpu es grande, pero tiene sus límites."
  },
  {
    "objectID": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html",
    "href": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html",
    "title": "Introduction to marbec-data and marbec-gpu",
    "section": "",
    "text": "Image credits: Diego Fernandez at Unplash"
  },
  {
    "objectID": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#what-are-they-are-they-the-same",
    "href": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#what-are-they-are-they-the-same",
    "title": "Introduction to marbec-data and marbec-gpu",
    "section": "What are they? Are they the same?",
    "text": "What are they? Are they the same?\nNo. marbec-data and marbec-gpu compose a High-performance computing (HPC) system. Basically, it is like having a supercomputer at your disposal to solve complex problems. Imagine that instead of having a single processor (Intel/AMD) working in conjunction with the RAM and storage space of your laptop, you have several computers linked together combining their power (processors, RAM and storage) to run complex processes. This is how HPC works: it uses multiple computers working together to solve very large computations much faster than a single computer could. Within Marbec, marbec-data is a Network File System (NFS) and marbec-gpu is a computing cluster.\nAn NFS is a network protocol that allows multiple devices connected to a network to share files and directories. This means that researchers can store their data, codes and outputs as if they were on their own local computer, but with the advantage of having a centralized backup and the ability to access their files from any machine connected to the cluster. In very simple words and going back to the analogy with your laptop, marbec-data takes the place of storage (i.e. hard disk). On the other hand, a compute cluster is, in essence, a set of interconnected processors working in a coordinated manner to execute complex computational processes. Within the analogy of your current PC, marbec-gpu equals: your main processor (CPU), your graphics processor (GPU), general RAM and video RAM.\nTo put it in raw numbers, the current (October 2024) potential of marbec-gpu is:\n\nCPU: 4 x [Intel(R) Xeon(R) Platinum 8380 @2.30GHz, 40 physical cores, 80 logical cores]\nRAM: 1.5 TB DDR4\nGPU: 2 x [NVIDIA A40, 48 GB ECC GDDR6 RAM, 10’752 CUDA cores, 336 tensor cores, 696 GB/s bandwidth]\n\nOf course, with these simplifications we are leaving out some important details, but we will go into more detail later as we need them."
  },
  {
    "objectID": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#how-to-access-marbec-data",
    "href": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#how-to-access-marbec-data",
    "title": "Introduction to marbec-data and marbec-gpu",
    "section": "How to access marbec-data?",
    "text": "How to access marbec-data?\nThis will depend on what we need to do. If we just want to take a quick look at the files and review aspects of our account, we can open a browser window and go to https://marbec-data.ird.fr/. This will open a login interface where you just need to enter your credentials.\n\nOnce inside, we will see a sort of desktop where we will see a couple of icons to access our shared directories and general documentation on the use of the platform.\n\nWe will start, however, by clicking on the user options icon (the one that looks like a little person) at the top right of the desktop and selecting the Personal option.\n\nA small window will open where we will be able to change our password (it is recommended that this is the FIRST thing we do if it is the first time we access), the interface language or desktop image and colors (in the Display Preferences tab).\n\nLikewise, in the Quota tab we will be able to verify the storage limit assigned to our user and what has been used so far in each of the folders associated to our user. This is a simple and graphic way to visualize the available space we have left. If at any time we need more space, we just need to request it by e-mail to the marbec-data administrators.\n\n\n\n\n\n\n\nImportant\n\n\n\nIf at any time during the execution of a process the allocated quota limit is reached, the system will block any attempt to save files and this will result in the unplanned termination of the process or errors related to disk write problems."
  },
  {
    "objectID": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#how-to-access-marbec-gpu",
    "href": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#how-to-access-marbec-gpu",
    "title": "Introduction to marbec-data and marbec-gpu",
    "section": "How to access marbec-gpu?",
    "text": "How to access marbec-gpu?\nThe easiest way to access marbec-gpu is through a browser using the JupyterLab environment. To do this, just open a browser (Chrome, Firefox, Brave, etc.) window and go to https://marbec-gpu.ird.fr/. A window will appear to enter our credentials (NOTE: They are not necessarily the same as those of marbec-data) and then click on the Start my server button. Next, a drop-down menu will appear where we will be able to choose different default configurations of computing power for our session.\n\n\n\n\n\n\nNote\n\n\n\nAlthough we indicated a moment ago that marbec-gpu has a good amount of CPUs, GPUs and RAM, this represents 100% of its absolute power and marbec-gpu is a shared service, so it is not possible for a single user to monopolize 100% of its capacity. That is why the first choice will consist of deciding what is the power we require for our process. For example, if we want to run an automated process of downloading satellite information, it will be enough to reserve 1 CPU and 2GB of RAM. On the other hand, if our script is only configured (and tested) to use CPU cores, it will not be necessary to reserve those configurations that include GPU. Remember that if you select a very powerful option that you will not take advantage of, it will not be available for someone else who might really need it (choose wisely).\n\n\n\nAfter selecting (and reserving) the resources for our session and clicking Start, a window with the JupyterLab Launcher will appear. In it, we will be able to see the different preinstalled and available applications. The main one will be the Terminal, which is the one we will use to launch (execute) our processes (scripts).\n\nWe will start by opening a Terminal window (by clicking on the corresponding icon) and the first command we will execute will be to change the password. To do this, we will execute the command passwd (and Enter). Next, we will be asked to type our current password and the new one. WARNING: by default and for security, during the password change process NO cursor is shown while typing, so it might seem that our keyboard is not working, but this is not the case. You can type normally.\n\n\n\n\n\n\nImportant\n\n\n\nIt is very important to define strong passwords (alphanumeric with symbols and uppercase-case) and preferably different passwords for the login in marbec-data and marbec-gpu. On the other hand, the JupyterLab environment DOES allow the use of classic shortcuts like Ctrl+C-Ctrl+V (or Cmd+C-Cmd+V in MacOS) to copy-paste character strings, so it is possible to use them during the password change process with the passwd command."
  },
  {
    "objectID": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#qué-son-son-lo-mismo",
    "href": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#qué-son-son-lo-mismo",
    "title": "Introduction to marbec-data and marbec-gpu",
    "section": "¿Qué son? ¿Son lo mismo?",
    "text": "¿Qué son? ¿Son lo mismo?\nNo. marbec-data y marbec-gpu componen un Sistema de cómputo de alto rendimiento (High-performance computing). (Muy) Básicamente, es como tener una supercomputadora a tu disposición para resolver problemas complejos. Imagina que en lugar de tener un único procesador (Intel/AMD) trabajando en conjunto con la RAM y el espacio de almacenamiento de únicamente tu computadora (e.g. tu laptop), tienes a varias computadoras unidas entre sí combinando su potencia (procesadores, RAM y almacenamiento) para ejecutar los un proceso complejo. Así es como funciona un HPC: utiliza múltiples computadoras trabajando juntas para resolver cálculos muy grandes mucho más rápido de lo que una sola computadora podría hacerlo. Dentro de Marbec, marbec-data es un sistema de almacenamiento distribuido (Network File System, NFS) y marbec-gpues un clúster de cómputo.\nUn NFS es un protocolo de red que permite a múltiples dispositivos conectados a una red compartir archivos y directorios. Esto significa que los investigadores pueden almacenar sus datos, códigos y resultados como si estuvieran en su propio equipo local, pero con la ventaja de tener una copia de seguridad centralizada y la posibilidad de acceder a sus archivos desde cualquier máquina conectada al clúster. En palabras muy simples y volviendo a la analogía con tu actual PC, marbec-data hace las veces del almacenamiento (i.e. del disco duro). Por otro lado, un clúster de cómputo es, en esencia, un conjunto de procesadores interconectados que trabajan de forma coordinada para ejecutar procesos computacionales complejos. Dentro de la analogía de tu PC actual, marbec-gpu equivale a: tu procesador principal (CPU), tu procesador de gráficos (GPU), la RAM general y la de vídeo.\nPara ponerlo en números brutos, la potencial actual (octubre 2024) de marbec-gpu es de:\n\nCPU: 4 x [Intel(R) Xeon(R) Platinum 8380 @2.30GHz, 40 physical cores, 80 logical cores]\nRAM: 1.5 TB DDR4\nGPU: 2 x [NVIDIA A40, 48 GB ECC GDDR6 RAM, 10’752 CUDA cores, 336 tensor cores, 696 GB/s bandwidth]\n\nPor supuesto, con estas simplificaciones estamos obviando algunos detalles importantes, pero que iremos detallando posteriormente conforme los necesitemos."
  },
  {
    "objectID": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#cómo-acceder-a-marbec-data",
    "href": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#cómo-acceder-a-marbec-data",
    "title": "Introduction to marbec-data and marbec-gpu",
    "section": "¿Cómo acceder a marbec-data?",
    "text": "¿Cómo acceder a marbec-data?\nEsto dependerá de lo que necesitemos hacer. Si únicamente queremos echar un vistazo rápido a los archivos y revisar aspectos de nuestra cuenta, bastará con abrir una ventana de navegador e ir a la dirección https://marbec-data.ird.fr/. Se abrirá una interfaz de logueo en donde bastará con colocar nuestras credenciales de acceso.\n\nUna vez adentro, veremos una suerte de escritorio en donde se mostrará un par de íconos de acceso a nuestros directorios compartidos y a documentación general de uso de la plataforma.\n\nEmpezaremos, sin embargo, con un click sobre el ícono de opciones de usuario (el que parece una personita) que se halla arriba a la derecha del escritorio y seleccionaremos la opción Personal.\n\nSe abrirá una pequeña ventana en donde podremos cambiar nuestra contraseña (se recomienda que esto sea lo PRIMERO que hagamos si es la primera vez que accedemos), el idioma de la interfaz o la imagen de escritorio y los colores (en la pestañana Display Preferences).\n\nAsí mismo, en la pestaña Quota podremos verificar el límite de almacenamiento asignado a nuestro usuario y lo utilizado hasta el momento en cada una de las carpetas asociadas a nuestro usuario. Esta es una manera sencilla y gráfica de visualizar el espacio disponible que nos queda. Si en algún momento necesitamos de más espacio, basta con solicitarlo por e-mail a los administradores de marbec-data.\n\n\n\n\n\n\n\nImportant\n\n\n\nSi en algún momento durante la ejecución de un proceso se alcanza el límite de la cuota asignada, el sistema bloqueará cualquier intento de guardado de archivos y esto dará lugar a la finalización imprevista del proceso o a errores relacionados a problemas de escritura en disco."
  },
  {
    "objectID": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#cómo-acceder-a-marbec-gpu",
    "href": "blog/marbec-data-gpu-intro/marbec-data-gpu-intro.html#cómo-acceder-a-marbec-gpu",
    "title": "Introduction to marbec-data and marbec-gpu",
    "section": "¿Cómo acceder a marbec-gpu?",
    "text": "¿Cómo acceder a marbec-gpu?\nLa manera más sencilla de acceder a marbec-gpu es a través de un navegador utilizando el entorno de JupyterLab. Para esto, bastará con abrir una ventana de navegador (Chrome, Firefox, Brave, etc.) e ir a la dirección https://marbec-gpu.ird.fr/. Se mostrará una ventana para ingresar nuestras credenciales (OJO: No necesariamente son las mismas que las de marbec-data) y posteriormente daremos click al botón de Start my server. A continuación, se mostrará un menú desplegable en donde podremos elegir diferentes configuraciones predeterminadas de potencia de cálculo para nuestra sesión.\n\n\n\n\n\n\nNote\n\n\n\nSi bien, hace un momento indicamos que marbec-gpu dispone de una buena cantidad CPUs, GPUs y RAM, eso representa el 100% de su potencia absoluta y marbec-gpu es un servicio compartido, por lo que no es posible que un solo usuario pueda acaparar el 100% de su capacidad. Es por ello que la primera elección consistirá en decidir cuál es la potencia que requerimos para nuestro proceso. Por ejemplo, si lo que deseamos es ejecutar un proceso de automatizado de descarga de información satelital, bastará con reservar 1 CPU y 2GB de RAM. De otro modo, si nuestro script solo está configurado (y probado) para utilizar núcleos de CPU, no es necesario reservar aquellas configuraciones que incluyan GPU. Recuerda que si seleccionas una opción muy potente que no aprovecharás, no estará disponible para alguien más que sí podría necesitarla realmente (elige sabiamente).\n\n\n\nLuego de haber seleccionado (y reservado) los recursos para nuestra sesión y haberle dado click a Start, se nos mostrará una ventana con el Launcher de JupyterLab. En ella, podremos observar los distintos aplicativos preinstalados y disponibles. El principal de todos será el de Terminal, que es con el que lanzaremos (ejecutaremos) nuestros procesos (scripts).\n\nEmpezaremos por abrir una ventana de Terminal (dándole click al ícono correspondiente) y el primer comando que ejecutaremos será el de cambio de contraseña. Para ello, ejecutaremos el comando passwd (y Enter). A continuación, nos solicitará que escribamos nuestra contraseña actual y la nueva. OJO: por defecto y por seguridad, durante el proceso de cambio de contraseña NO se muestra ningún cursor mientras se escribe, así que podría parecer que nuestro teclado no está funcionando, pero esto no es así. Usted escriba con normalidad.\n\n\n\n\n\n\nImportant\n\n\n\nEs muy importante que se defina contraseñas seguras (alfanuméricas con símbolos y mayúsculas-minúsculas) y de preferencia distintas para el inicio de sesión en marbec-data y marbec-gpu. Por otro lado, el entorno de JupyterLab SÍ permite el uso de shortcuts clásicos como Ctrl+C-Ctrl+V (o Cmd+C-Cmd+V en MacOS) para copiar-pegar cadenas de carcateres, por lo que es posible utilizarlos durante el proceso de cambio de contraseña con el comando passwd."
  },
  {
    "objectID": "blog/marbec-data-manage-files/marbec-data-manage-files.html",
    "href": "blog/marbec-data-manage-files/marbec-data-manage-files.html",
    "title": "Managing files within marbec-data",
    "section": "",
    "text": "Image credits: Declan Sun at Unplash"
  },
  {
    "objectID": "blog/marbec-data-manage-files/marbec-data-manage-files.html#create-a-shared-work-folder",
    "href": "blog/marbec-data-manage-files/marbec-data-manage-files.html#create-a-shared-work-folder",
    "title": "Managing files within marbec-data",
    "section": "Create a shared work folder",
    "text": "Create a shared work folder\n[Content in preparation]"
  },
  {
    "objectID": "blog/marbec-data-manage-files/marbec-data-manage-files.html#linking-a-working-folder-to-marbec-gpu.",
    "href": "blog/marbec-data-manage-files/marbec-data-manage-files.html#linking-a-working-folder-to-marbec-gpu.",
    "title": "Managing files within marbec-data",
    "section": "Linking a working folder to marbec-gpu.",
    "text": "Linking a working folder to marbec-gpu.\n[Content in preparation]"
  },
  {
    "objectID": "blog/marbec-data-manage-files/marbec-data-manage-files.html#managing-files-between-marbec-data-and-our-pc-filezilla",
    "href": "blog/marbec-data-manage-files/marbec-data-manage-files.html#managing-files-between-marbec-data-and-our-pc-filezilla",
    "title": "Managing files within marbec-data",
    "section": "Managing files between marbec-data and our PC (FileZilla)",
    "text": "Managing files between marbec-data and our PC (FileZilla)\n\nInstalling FileZilla and connecting to marbec-data.\nThe easiest way to move (copy, cut and paste) files from our PC to one of our shared work folders or to our marbec-gpu user folder is through the (free) FileZilla software. To download the installer, just go to its official website https://filezilla-project.org/ and select the Download FileZilla Client button.\n\nThen, by default we will be offered to download the version corresponding to the operating system (OS) where we are running our browser, but we can always choose the most appropriate version in the section More download options.\n\n\n\n\n\n\n\nOperating systems and CPU architectures\n\n\n\nIn recent years, processors with ARM architecture have been incorporated into the PC market. The most recent and famous example is Apple’s Mx series (e.g. M1); however, in recent months laptops with ARM processors (from the Snapdragon brand, for instance) have also appeared. Software compiled for an ARM architecture will not work on an x86 architecture (which is the architecture manufactured by brands such as Intel or AMD) and vice versa, so it will always be important to know not only which OS our PC is running (Windows, MacOS or Linux), but also the architecture of our processor.\n\n\nOnce the file has been downloaded, it will be enough to run it leaving most of the options by default (except those that offer us to install some additional program that we do not need, e.g. Chrome). After that, we will be able to run the program and we will obtain an environment that will look like this:\n\nThe next thing we will do is to establish a connection to marbec-data. To do this, at the top, we will fill in the following fields:\n\nServer: marbec-data.ird.fr\nUser: youruser\nPassword: yourpassword\nPort: 22\n\nIf all goes well, a message indicating that the connection has been successful will be displayed in the panel immediately below. In addition, the next two lower panels to the right will show those folders already linked and available in our marbec-data account.\n\n\n\n\n\n\n\nNote\n\n\n\nIt is not necessary to log in every time we log back into FileZilla. We could save our login and skip the above steps by clicking the small arrow to the right of Quick Login and selecting our saved login. Of course, allowing our login credentials to be saved should ONLY occur on our personal PC.\n\n\n\nAnd that is all! In the left panels, we will be able to navigate in the directories of our PC, while in the right panels we will be able to do it in the marbec-gpu and marbec-data ones.\n\n\nCopying files and folders\nIt will be as simple as dragging the element between the left and right panels. The process will start and the bottom pane (the last one) will show the queued, completed and failed transfers.\n\nAlso, if at any time FileZilla detects that there are repeated items, it will show a small window with multiple options available (overwrite and skip, verify differences in sizes or names, apply the selected option to future cases in the transfer queue, etc.)."
  },
  {
    "objectID": "blog/marbec-data-manage-files/marbec-data-manage-files.html#manage-files-within-marbec-data.",
    "href": "blog/marbec-data-manage-files/marbec-data-manage-files.html#manage-files-within-marbec-data.",
    "title": "Managing files within marbec-data",
    "section": "Manage files within marbec-data.",
    "text": "Manage files within marbec-data.\nWhile the marbec-data web environment explorer offers the options to copy, paste, delete, etc., it is not an efficient method when our files are medium or large (&gt;10 MB). Here is how to perform these operations from Terminal.\n\nCopy-paste\nFor this, the simplest way is through the cp command and making use of the navigation commands cited in this post (e.g. .. to indicate a previous folder). The basic syntax is the following: cp path/origin /path/destination, but there are different possible cases:\n\nCopy a file into the same folder, but with a different name (create duplicate): cp file1.csv file1-dup.csv.\nCopy a file to another folder: cp path/file1.csv path/destination.\nCopy more than one file to another folder: cp path/file1.csv path/file2.csv folder/destination\nCopy a folder to another folder: cp path/folder1 path/folder2 --recursive or cp path/folder1 path/folder2 -r.\n\n\n\n\n\n\n\nNote\n\n\n\nBy default, cp will overwrite any file with the same name. To avoid this, it is possible to add the -n option as follows: cp path/from/file1.csv path/destination -n.\n\n\n\n\nCut-paste (and also rename)\nIt will be very similar to the above, but through the mv command:\n\nRename a file (within the same folder): mv file1.csv file2.csv\nMove a file to another folder: mv path/file1.csv path/to/destination\nMove one file to another folder: mv path/file1.csv path/file2.csv path/destination\nMove one folder to another folder: mv path/old/folder path/new/folder\n\n\n\nDelete\nFor this, we will use the rm command as follows:\n\nDelete a file: rm path/to/file.csv\nDelete a folder (and all its contents): rm path/to/folder -r\n\n\n\n\n\n\n\nNo turning back\n\n\n\nWhile inside Terminal it is always possible to cancel a command using the shortcut Ctrl+C (or Cmd+C on MacOS), once the rm command completes its work, there is no way to revert the deletion or recover it from a recycle garbage can, so be very careful when using it."
  },
  {
    "objectID": "blog/marbec-data-manage-files/marbec-data-manage-files.html#crear-una-carpeta-de-trabajo-compartida",
    "href": "blog/marbec-data-manage-files/marbec-data-manage-files.html#crear-una-carpeta-de-trabajo-compartida",
    "title": "Managing files within marbec-data",
    "section": "Crear una carpeta de trabajo compartida",
    "text": "Crear una carpeta de trabajo compartida\n[Contenido en preparación]"
  },
  {
    "objectID": "blog/marbec-data-manage-files/marbec-data-manage-files.html#enlazar-una-carpeta-de-trabajo-a-marbec-gpu",
    "href": "blog/marbec-data-manage-files/marbec-data-manage-files.html#enlazar-una-carpeta-de-trabajo-a-marbec-gpu",
    "title": "Managing files within marbec-data",
    "section": "Enlazar una carpeta de trabajo a marbec-gpu",
    "text": "Enlazar una carpeta de trabajo a marbec-gpu\n[Contenido en preparación]"
  },
  {
    "objectID": "blog/marbec-data-manage-files/marbec-data-manage-files.html#gestionar-archivos-entre-marbec-data-y-nuestra-pc-filezilla",
    "href": "blog/marbec-data-manage-files/marbec-data-manage-files.html#gestionar-archivos-entre-marbec-data-y-nuestra-pc-filezilla",
    "title": "Managing files within marbec-data",
    "section": "Gestionar archivos entre marbec-data y nuestra PC (FileZilla)",
    "text": "Gestionar archivos entre marbec-data y nuestra PC (FileZilla)\n\nInstalando FileZilla y conectándonos a marbec-data\nLa manera más sencilla de mover (copiar, cortar y pegar) archivos desde nuestra PC hacia alguna de nuestras carpetas de trabajos compartidas o hacia nuestra carpeta de usuario de marbec-gpu es a través del software (gratuito) FileZilla. Para descargar el instalador, basta con ir a su sitio web oficial https://filezilla-project.org/ y seleccionar el botón Download FileZilla Client.\n\nLuego, por defecto se nos ofrecerá descargar la versión correspondiente al sistema operativo (SO) en donde estemos ejecutando nuestro navegador, pero siempre podremo elegir la versión más adecuada en la sección More download options.\n\n\n\n\n\n\n\nSistemas Operativos y arquitecturas de procesador\n\n\n\nEn los últimos años, se ha ido incorporando al mercado de PCs los procesadores con arquitectura ARM. El ejemplo más reciente y famoso es la serie Mx de Apple (e.g. M1); sin embargo, en los últimos meses también han aparecido laptops con procesadores ARM (de la marca Snapdragon, por ejemplo). Un software compilado para una arquitectura ARM no funcionará en una arquitectura x86 (que es la arquitectura fabricada por marcas como Intel o AMD) y viceversa, por lo que siempre será importante conocer no solamente qué SO lleva nuestra PC (Windows, MacOS o Linux), sino también la arquitectura de nuestro procesador.\n\n\nUna vez descargado el archivo, bastará con ejecutarlo dejando la mayor parte de opciones por defecto (salvo aquellas que nos ofrezcan instalar algún programa adicional que no necesitemos, e.g. Chrome). Luego de ello, podremos ejecutar el programa y obtendremos un entorno que lucirá así:\n\nLo siguiente que haremos será establecer una conexión a marbec-data. Para ello, en la parte superior, completaremos los siguientes campos:\n\nServidor: marbec-data.ird.fr\nUsuario: nuestrousuario\nContraseña: nuestracontraseña\nPuerto: 22\n\nSi todo va bien, en el panel inmediato inferior se mostrará un mensaje indicado que la conexión ha sido exitosa. Además, en los dos paneles inferiores siguientes a la derecha se mostrará aquellas carpetas ya enlazadas y disponibles en nuestra cuenta de marbec-data.\n\n\n\n\n\n\n\nNote\n\n\n\nNo es necesario iniciar sesión cada vez que ingresemos nuevamente a FileZilla. Si decidimos que deseamos que guarde nuestro inicio de sesión, podremos obviar los pasos anteriores dando click a la pequeña flecha a la derecha de Conexión rápida y seleccionando nuestro inició de sesión guardado. Por supuesto, el permitir que se guarden nuestras credenciales de inicio de sesión SOLO debe ocurrir en nuestra PC de uso personal.\n\n\n\n¡Y eso es todo! En los paneles de la izquierda, podremos navegar en los directorios de nuestra PC, mientras que en los paneles de la derecha podremos hacerlo en los de marbec-gpu y marbec-data.\n\n\nCopiar archivos y carpetas\nSerá tan sencillo como arrastrar el elemento entre los paneles izquierdo y derecho. El proceso iniciará y en el panel inferior (el último) se mostrará las transferencias en cola, las completadas y las fallidas.\n\nAsí mismo, si en algún momento FileZilla detecta que hay elementos repetidos, nos mostrará una ventana pequeña con múltiples opciones disponibles (sobreescribir y omitir, verificar diferenencias en tamaños o nombres, aplicar la opción seleccionada a futuros casos en la cola de transferencia, etc.)."
  },
  {
    "objectID": "blog/marbec-data-manage-files/marbec-data-manage-files.html#gestionar-archivos-dentro-de-marbec-data",
    "href": "blog/marbec-data-manage-files/marbec-data-manage-files.html#gestionar-archivos-dentro-de-marbec-data",
    "title": "Managing files within marbec-data",
    "section": "Gestionar archivos dentro de marbec-data",
    "text": "Gestionar archivos dentro de marbec-data\nSi bien el explorador del entorno web de marbec-data ofrece las opciones de copiar, pegar, eliminar, etc., no es un método eficiente cuando nuestros archivos son medianos o grandes (&gt;10 MB). A continuación, se mostrará cómo realizar estas operaciones desde Terminal.\n\nCopiar-pegar\nPara esto, la manera más sencilla es a través del comando cp y haciendo uso de los comandos de navegación citados en este post (e.g. .. para indicar una carpeta anterior). La sintaxis básica es la siguiente: cp ruta/de/origen ruta/de/destino, pero existen diferentes casos posibles:\n\nCopiar un archivo dentro de la misma carpeta, pero con un nombre distinto (crear duplicado): cp archivo1.csv archivo1-dup.csv\nCopiar un archivo hacia otra carpeta: cp ruta/de/archivo1.csv carpeta/de/destino\nCopiar más de un archivo hacia otra carpeta: cp ruta/de/archivo1.csv ruta/de/archivo2.csv carpeta/de/destino\nCopiar una carpeta en otra carpeta: cp ruta/de/carpeta1 ruta/de/carpeta2 --recursive o cp ruta/de/carpeta1 ruta/de/carpeta2 -r\n\n\n\n\n\n\n\nNote\n\n\n\nPor defecto, cp sobreescribirá cualquier archivo con el mismo nombre. Para evitarlo, es posible añadir la opción -n del siguiente modo: cp ruta/de/archivo1.csv ruta/de/destino -n\n\n\n\n\nCortar-pegar (y también renombrar)\nSerá muy similar a lo anterior, pero a través del comando mv:\n\nRenombrar un archivo (dentro de la misma carpeta): mv archivo1.csv archivo2.csv\nMover un archivo hacia otra carpeta: mv ruta/de/archivo1.csv carpeta/de/destino\nMover más de un archivo hacia otra carpeta: mv ruta/de/archivo1.csv ruta/de/archivo2.csv carpeta/de/destino\nMover una carpeta hacia otra carpeta: mv ruta/antigua/carpeta ruta/nueva/carpeta\n\n\n\nBorrar\nPara esto, utilizaremos el comando rm de la siguiente manera:\n\nBorrar un archivo: rm ruta/de/archivo.csv\nBorrar una carpeta (y todo su contenido): rm ruta/de/carpeta -r\n\n\n\n\n\n\n\nNo hay vuelta atrás\n\n\n\nSi bien dentro de Terminal siempre es posible cancelar una orden usando el atajo Ctrl+C (o Cmd+C en MacOS), una vez que se ejecuta el comando rm y éste culmina su trabajo, no hay manera de revertir lo borrado ni recuperarlo desde alguna papelera de reciclaje, así que ten mucho cuidado al usarlo."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Wencheng Lau-Medrano",
    "section": "",
    "text": "Note\n\n\n\nOne surface, dos idiomas.\nHere you will find content in two languages: English (EN) and Spanish (ES). Each piece of content will be available in both languages.\nEn esta página encontrarás contenido en dos idiomas: inglés (EN) y español (ES). Cada sección estará disponible en ambos idiomas.\n\n\n\n[EN] Beneath the surface 🌊\nHi there! I’m (Luis) Wencheng Lau-Medrano, a passionate enthusiast of technology, marine biology, data analysis, Legos, and travel. Here I will share some of what I know, have learned, and experienced in those fields. You will find everything from practical tips to improve your programming and data analysis skills to recommendations for tourist destinations and guides for administrative procedures. Thank you for being a part of this journey of learning and discovery.\nBelow are my main networks and ways to contact me. Feel free to send me a message about any of the contents.\nImage credits: Dan Grinwis at Unplash\n\n\n[ES] Bajo la superficie 🌊\n¡Hola, qué tal! Soy (Luis) Wencheng Lau-Medrano, un apasionado de la tecnología, la biología marina, el análisis de datos, los Legos y los viajes. Aquí compartiré un poco de lo que sé, aprendí y experimenté en esos campos. Encontrarás desde consejos prácticos para mejorar tus habilidades en programación y análisis de datos, hasta recomendaciones de destinos turísticos y guías para realizar trámites administrativos. Gracias por ser ahora parte de ese viaje de aprendizaje y descubrimiento.\nAbajo están mis principales redes y formas de contacto. No dudes en enviarme un mensaje acerca de cualquiera de los contenidos.\nCréditos de la imagen: Dan Grinwis en Unplash"
  }
]